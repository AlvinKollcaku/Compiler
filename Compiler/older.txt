void reorganizeStack(int a1,int a2,char operator,bool isVariableIncluded,PostfixPtr* topPtr)
{
    /*
     1)Put the load and add/sub.. operations in SML
     2)Put the result of SML[a1] operator SML[a2] into the symbol table as new constant with
     a location in the SML array (resultLocation)
     3)STORE resultLocation
     */
    double result=0;
    char str[50];
    int resultLocation;
    switch(operator)
    {
        case '+':
            SML[SmlInstructionCounter++]=20000+a1; //LOAD a1
            SML[SmlInstructionCounter++]=30000+a2;//ADD a2 ->Now the result is in the accumulator

            if(isVariableIncluded)//the result will be stored in the next free spot
            {
                SML[SmlInstructionCounter++]=21000+SmlVariableIndexCounter;
                pushPostfix(topPtr,SmlVariableIndexCounter);//Pushing the address with the result into the stack
                SmlVariableIndexCounter--;
            }else
            {
                result=SML[a1]+SML[a2];
                snprintf(str, sizeof(str), "%f", result);//turns float to string
                resultLocation= returns_SML_location_from_SymbolTable(str);
                if(resultLocation==-1)
                {
                    SymbolTable[SymbolTableIndex].symbol=result;
                    SymbolTable[SymbolTableIndex].type='C';
                    SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                    resultLocation=SmlVariableIndexCounter+1;
                }
                SML[SmlInstructionCounter++]=21000+resultLocation;
                pushPostfix(topPtr,resultLocation);//Pushing the address with the result into the stack
            }
            break;
        case '-':
            SML[SmlInstructionCounter++]=20000+a1; //LOAD a1
            SML[SmlInstructionCounter++]=31000+a2;//SUBTRACT a2
            if(isVariableIncluded)//the result will be stored in the next free spot
            {
                SML[SmlInstructionCounter++]=21000+SmlVariableIndexCounter;
                pushPostfix(topPtr,SmlVariableIndexCounter);//Pushing the address with the result into the stack
                SmlVariableIndexCounter--;
            }else
            {
                result=SML[a1]-SML[a2];
                snprintf(str, sizeof(str), "%f", result);//turns float to string
                resultLocation= returns_SML_location_from_SymbolTable(str);
                if(resultLocation==-1)
                {
                    SymbolTable[SymbolTableIndex].symbol=result;
                    SymbolTable[SymbolTableIndex].type='C';
                    SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                    resultLocation=SmlVariableIndexCounter+1;
                }
                SML[SmlInstructionCounter++]=21000+resultLocation;
                pushPostfix(topPtr,resultLocation);//Pushing the address with the result into the stack

            }
            break;
        case '*':
            SML[SmlInstructionCounter++]=20000+a1; //LOAD a1
            SML[SmlInstructionCounter++]=33000+a2;//MULTIPLY a2
            if(isVariableIncluded)//the result will be stored in the next free spot
            {
                SML[SmlInstructionCounter++]=21000+SmlVariableIndexCounter;
                pushPostfix(topPtr,SmlVariableIndexCounter);//Pushing the address with the result into the stack
                SmlVariableIndexCounter--;
            }else
            {
                result=SML[a1]*SML[a2];
                snprintf(str, sizeof(str), "%f", result);//turns float to string
                resultLocation= returns_SML_location_from_SymbolTable(str);
                if(resultLocation==-1)
                {
                    SymbolTable[SymbolTableIndex].symbol=result;
                    SymbolTable[SymbolTableIndex].type='C';
                    SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                    resultLocation=SmlVariableIndexCounter+1;
                }
                SML[SmlInstructionCounter++]=21000+resultLocation;
                pushPostfix(topPtr,resultLocation);//Pushing the address with the result into the stack

            }
            break;
        case '/':
            SML[SmlInstructionCounter++]=20000+a1; //LOAD a1
            SML[SmlInstructionCounter++]=32000+a2;//DIV a2
            if(isVariableIncluded)//the result will be stored in the next free spot
            {
                SML[SmlInstructionCounter++]=21000+SmlVariableIndexCounter;
                pushPostfix(topPtr,SmlVariableIndexCounter);//Pushing the address with the result into the stack
                SmlVariableIndexCounter--;
            }else
            {
                result=SML[a1]/SML[a2];
                snprintf(str, sizeof(str), "%f", result);//turns float to string
                resultLocation= returns_SML_location_from_SymbolTable(str);
                if(resultLocation==-1)
                {
                    SymbolTable[SymbolTableIndex].symbol=result;
                    SymbolTable[SymbolTableIndex].type='C';
                    SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                    resultLocation=SmlVariableIndexCounter+1;
                }
                SML[SmlInstructionCounter++]=21000+resultLocation;
                pushPostfix(topPtr,resultLocation);//Pushing the address with the result into the stack
            }
            break;
        case '%':
            SML[SmlInstructionCounter++]=20000+a1; //LOAD a1
            SML[SmlInstructionCounter++]=34000+a2;//REMAINDER a2

            if(isVariableIncluded)//the result will be stored in the next free spot
            {
                SML[SmlInstructionCounter++]=21000+SmlVariableIndexCounter;
                pushPostfix(topPtr,SmlVariableIndexCounter);//Pushing the address with the result into the stack
                SmlVariableIndexCounter--;
            }else
            {
                result=(int)SML[a1]%(int)SML[a2];
                snprintf(str, sizeof(str), "%f", result);//turns float to string
                resultLocation= returns_SML_location_from_SymbolTable(str);
                if(resultLocation==-1)
                {
                    SymbolTable[SymbolTableIndex].symbol=result;
                    SymbolTable[SymbolTableIndex].type='C';
                    SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                    resultLocation=SmlVariableIndexCounter+1;
                }
                SML[SmlInstructionCounter++]=21000+resultLocation;
                pushPostfix(topPtr,resultLocation);//Pushing the address with the result into the stack
            }
            break;
        case '^':
            SML[SmlInstructionCounter++]=20000+a1; //LOAD a1
            SML[SmlInstructionCounter++]=35000+a2;//EXPONENTIATION a2

            if(isVariableIncluded)//the result will be stored in the next free spot
            {
                SML[SmlInstructionCounter++]=21000+SmlVariableIndexCounter;
                pushPostfix(topPtr,SmlVariableIndexCounter);//Pushing the address with the result into the stack
                SmlVariableIndexCounter--;
            }else
            {
                result=pow(SML[a1],SML[a2]);
                snprintf(str, sizeof(str), "%f", result);//turns float to string
                resultLocation= returns_SML_location_from_SymbolTable(str);
                if(resultLocation==-1)
                {
                    SymbolTable[SymbolTableIndex].symbol=result;
                    SymbolTable[SymbolTableIndex].type='C';
                    SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                    resultLocation=SmlVariableIndexCounter+1;
                }
                SML[SmlInstructionCounter++]=21000+resultLocation;
                pushPostfix(topPtr,resultLocation);//Pushing the address with the result into the stack
            }
            break;
        default:
            printf("Not valid operator");
            exit(1);
    }
}

int evaluatePostfixExpression2(char *expr[])
{
    PostfixPtr topPtr=NULL;
    char * pend;// Character end pointer  -> for strof
    bool isVariableIncluded=false;

    for(int i=0; strcmp(expr[i],"$") != 0; i++)
    {
        printf("Current: %s\n",expr[i] );
        if(isVariable(expr[i]))
        {
            printf("%c is variable\n", *expr[i]);
            if(returns_SML_location_from_SymbolTable(expr[i])==-1)
            {
                SymbolTable[SymbolTableIndex].symbol=(char)*expr[i];
                SymbolTable[SymbolTableIndex].type='V';
                SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
            }
            pushPostfix(&topPtr,returns_SML_location_from_SymbolTable(expr[i]));
        }else if(isOperator(*expr[i]))
        {
            printf("%c is operator\n",*expr[i]);
            //if we have an operator pop last 2 digits in stack to do the calculation
            int v2=popPostfix(&topPtr); //second operator address
            int v1=popPostfix(&topPtr); //first operator address

            if((isVariableInSymbolTable(v1) || isVariableInSymbolTable(v2))&& !isVariableIncluded)//to not check it again once it turns true
                isVariableIncluded=true;

            printf("Now reorganizing the stack\n");
            reorganizeStack(v1,v2,*expr[i],isVariableIncluded ,&topPtr);
            printf("Stack reorganized\n");
            printPostfixStack(topPtr);
        }
        else //It is a constant -> put it into the symbol table if it's not there
            // and push the location in the stack
        {
            printf("%lf is constant\n", strtof(expr[i], &pend));
            int resultLocation= returns_SML_location_from_SymbolTable(expr[i]);
            if(resultLocation==-1)
            {
                SymbolTable[SymbolTableIndex].symbol=strtof(expr[i], &pend);
                SymbolTable[SymbolTableIndex].type='C';
                SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
                resultLocation=SmlVariableIndexCounter+1;
                SML[SmlVariableIndexCounter+1]=strtof(expr[i], &pend);
            }
            pushPostfix(&topPtr,resultLocation);
        }
        printf("Next -> Comparing %s with \"$\" %d \n",expr[i+1],strcmp(expr[i+1],"$"));
    }
    printf("Value that is being returned %d\n",topPtr->address);
    return topPtr->address; //returning the address with the result
}

conditionKeyword()
{
    if(returns_SML_location_from_SymbolTable(tokenPtr)==-1)
        {
            SymbolTable[SymbolTableIndex].symbol=*tokenPtr;

            if(isVariable(tokenPtr))
                SymbolTable[SymbolTableIndex].type='V';
            else
                SymbolTable[SymbolTableIndex].type='C';

            SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
        }
        //Now we check the if cases by getting the next token
        tokenPtr=strtok(NULL," ");

        if(strlen(tokenPtr)==1)
        {
            if(isConditionalOperator(*tokenPtr))
                Operators[0] = *tokenPtr;
            else
            {
                printf("Not a valid operator: %c\n",*tokenPtr);
                exit(0);
            }
        }else
        {
            if(isConditionalOperator(tokenPtr[0])&& isConditionalOperator(tokenPtr[1])) {
                Operators[0] = tokenPtr[0];
                Operators[1] = tokenPtr[1];
            }
            else
            {
                printf("Not a valid operator: %c\n",*tokenPtr);
                exit(0);
            }
        }
        //printf("The operators are ready: %c %c \n",Operators[0],Operators[1]);
        tokenPtr=strtok(NULL," ");//getting the right part of the inequality

        if(isVariable(tokenPtr)||isConstant(tokenPtr))//TODO only checks if single letter V or single digit C
        {
            //We input the second operand in the symbol table if is not already there
            int l2=returns_SML_location_from_SymbolTable(tokenPtr);
            Operands[1]=tokenPtr;

            if(l2==-1)
            {
                SymbolTable[SymbolTableIndex].symbol=*tokenPtr;
                if(isKeyword(tokenPtr))
                    SymbolTable[SymbolTableIndex].type='V';
                else
                    SymbolTable[SymbolTableIndex].type='C';
                SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter--;
            }

           handleOperators(Operators,Operands,tokenPtr);
        }
        else
        {
            printf("The second operand should be a single letter variable or a constant");
            //Have to implement with goto and loop
            exit(0);
        }
}
void printS(char *tokenPtr)
{
    tokenPtr=strtok(NULL," "); //1)Going to the variable
    //printf("CurrentToken:%s\n",tokenPtr);
    if(!isValidVariable(tokenPtr))
    {
        printf("The variable after input keyword should be max 5 characters and should only contain letters"
               "->%s is not correct at line number %d",tokenPtr,lastValidLine);
        exit(1);
    }

    //printf("CASE:INPUT --> Value returned from function %d \n",x);
    int line=returns_SML_location_from_SymbolTable(tokenPtr);
    if(line==-1) //not in symbol table -> we put it there
    {
        //printf("Putting it in the symbol table\n");
        strcpy(SymbolTable[SymbolTableIndex].variable,tokenPtr);
        SymbolTable[SymbolTableIndex].type='S';
        SymbolTable[SymbolTableIndex++].location=SmlVariableIndexCounter;

        //printf("Inputted: %c\n",SymbolTable[SymbolTableIndex-1]);

        SML[SmlInstructionCounter++]=13000+SmlVariableIndexCounter;
        SmlVariableIndexCounter-=10;
        //1000 + the location for the referenced variable(which is the next token)
    }
    else
    {
        //We use its location in the symbol table
        SML[SmlInstructionCounter++]=13000+line;
    }
}

 remove_newline(tokenPtr);

    for(int i=0;i< strlen(tokenPtr);i++)
    {
        if(isspace(tokenPtr[i]))
            continue;

        if(tokenPtr[i]=='\"') //We are dealing with a string literal
        {
            char *noSpacesString=tokenPtr+i;
            if(isValidStringLiteral(noSpacesString))
            {
                strcpy(SymbolTable[SymbolTableIndex].variable,noSpacesString);
                SymbolTable[SymbolTableIndex].type='S';
                SymbolTable[SymbolTableIndex++].location=left_variable_location;

                size_t len = strlen(noSpacesString);
                //Now that we are dealing with a valid string we store it in memory in sequence

                SML[SmlVariableIndexCounter--]=(len-2)*10000+(int)noSpacesString[1]; //skipping \"

                for(int i=2;i<len-1;i++) //also skipping the last \" with len-1
                {
                    SML[SmlVariableIndexCounter--]=(int)noSpacesString[i];
                }
            }else
            {
                printf("Invalid string literal in let statement at line %d\n",lastValidLine);
                exit(1);
            }
            return;
        }
    }